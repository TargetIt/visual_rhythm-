# 节奏游戏 - 优化与扩展策略

## 1. 性能优化策略

### 1.1 渲染性能优化

#### Canvas优化技术

**分层Canvas（未来优化）：**
```javascript
// 静态层：背景、轨道（不常变化）
const staticCanvas = wx.createCanvas()
renderStaticElements(staticCanvas)

// 动态层：节拍、UI（频繁变化）
const dynamicCanvas = wx.createCanvas()
renderDynamicElements(dynamicCanvas)

// 最终合成
ctx.drawImage(staticCanvas, 0, 0)
ctx.drawImage(dynamicCanvas, 0, 0)
```

**优势：**
- 减少重绘次数：~40%
- 提升帧率：5-10 FPS
- 降低CPU占用：~30%

**离屏Canvas预渲染：**
```javascript
class TrackSystem {
  judgeZoneCache = null
  
  initJudgeZoneCache() {
    const canvas = wx.createCanvas()
    canvas.width = SCREEN_WIDTH
    canvas.height = SCREEN_HEIGHT / 3
    
    const ctx = canvas.getContext('2d')
    this.renderJudgeZone(ctx)
    
    this.judgeZoneCache = canvas
  }
  
  render(ctx) {
    // 使用缓存的判定区域
    if (this.judgeZoneCache) {
      ctx.drawImage(this.judgeZoneCache, 0, judgeZoneY)
    }
  }
}
```

**适用场景：**
- 判定区域（不变）
- 轨道背景（不变）
- UI元素（偶尔变化）

#### 绘制调用优化

**批量状态设置：**
```javascript
// 优化前：每次绘制都设置
notes.forEach(note => {
  ctx.fillStyle = note.color
  ctx.fillRect(note.x, note.y, note.width, note.height)
})

// 优化后：相同颜色批量绘制
const notesByColor = groupBy(notes, 'color')
notesByColor.forEach((group, color) => {
  ctx.fillStyle = color  // 只设置一次
  group.forEach(note => {
    ctx.fillRect(note.x, note.y, note.width, note.height)
  })
})
```

**性能提升：**
- 减少状态切换：~50%
- Canvas调用次数：-30%
- 帧时间：-2-3ms

**路径批处理：**
```javascript
// 优化后：使用路径批量绘制
ctx.beginPath()
notes.forEach(note => {
  ctx.rect(note.x, note.y, note.width, note.height)
})
ctx.fillStyle = color
ctx.fill()
```

### 1.2 内存优化

#### 对象池深度优化

**当前实现分析：**
```javascript
// 问题：对象池无大小限制
class Pool {
  pools = {}
  
  recover(name, obj) {
    this.pools[name].push(obj)  // 无限增长
  }
}
```

**优化方案：**
```javascript
class Pool {
  pools = {}
  maxPoolSize = {
    'note': 100,      // Note对象最多缓存100个
    'animation': 50   // Animation对象最多缓存50个
  }
  
  recover(name, obj) {
    const pool = this.pools[name] || (this.pools[name] = [])
    
    // 限制池大小
    if (pool.length < (this.maxPoolSize[name] || 50)) {
      pool.push(obj)
    }
    // 超出限制，让GC回收
  }
  
  // 获取池状态（调试用）
  getPoolStats() {
    const stats = {}
    Object.keys(this.pools).forEach(key => {
      stats[key] = {
        size: this.pools[key].length,
        max: this.maxPoolSize[key]
      }
    })
    return stats
  }
}
```

**效果：**
- 控制内存上限
- 避免内存泄漏
- 可监控可调试

#### 资源预加载与释放

**图片资源管理：**
```javascript
class ResourceManager {
  images = {}
  loadedCount = 0
  totalCount = 0
  
  preloadImages(imageList) {
    this.totalCount = imageList.length
    
    imageList.forEach(src => {
      const img = wx.createImage()
      img.onload = () => {
        this.loadedCount++
        if (this.loadedCount === this.totalCount) {
          this.onAllLoaded()
        }
      }
      img.src = src
      this.images[src] = img
    })
  }
  
  getImage(src) {
    return this.images[src]
  }
  
  // 释放不用的资源
  releaseImage(src) {
    delete this.images[src]
  }
}
```

**策略：**
- 游戏开始前预加载
- 显示加载进度
- 游戏结束后释放

#### 定时清理策略

**实现：**
```javascript
class DataBus {
  maintenanceInterval = 60 * 5  // 5秒（60FPS）
  maintenanceCounter = 0
  
  update() {
    this.maintenanceCounter++
    
    if (this.maintenanceCounter >= this.maintenanceInterval) {
      this.performMaintenance()
      this.maintenanceCounter = 0
    }
  }
  
  performMaintenance() {
    // 清理非活跃对象
    this.notes = this.notes.filter(n => n.isActive)
    this.animations = this.animations.filter(a => a.isPlaying)
    
    // 打印内存状态（开发模式）
    console.log('Pool stats:', this.pool.getPoolStats())
  }
}
```

### 1.3 计算性能优化

#### 避免重复计算

**缓存计算结果：**
```javascript
class TrackSystem {
  cachedJudgeZone = null
  screenHeightCache = 0
  
  getJudgeZone() {
    // 屏幕尺寸未变化，使用缓存
    if (this.cachedJudgeZone && 
        this.screenHeightCache === SCREEN_HEIGHT) {
      return this.cachedJudgeZone
    }
    
    // 重新计算
    this.screenHeightCache = SCREEN_HEIGHT
    this.cachedJudgeZone = this.calculateJudgeZone()
    return this.cachedJudgeZone
  }
}
```

**查找表优化：**
```javascript
// 优化前：每次三角函数计算
for (let i = 0; i < 8; i++) {
  const angle = (i * Math.PI * 2) / 8
  const x = centerX + Math.cos(angle) * radius
  const y = centerY + Math.sin(angle) * radius
}

// 优化后：预计算查找表
const ANGLE_TABLE = Array.from({ length: 8 }, (_, i) => ({
  cos: Math.cos((i * Math.PI * 2) / 8),
  sin: Math.sin((i * Math.PI * 2) / 8)
}))

for (let i = 0; i < 8; i++) {
  const x = centerX + ANGLE_TABLE[i].cos * radius
  const y = centerY + ANGLE_TABLE[i].sin * radius
}
```

#### 算法优化

**空间换时间 - 轨道索引：**
```javascript
// 优化前：每次遍历查找（O(n)）
getTrackByX(x) {
  for (let i = 0; i < 4; i++) {
    if (x >= this.tracks[i].x && 
        x < this.tracks[i].x + this.tracks[i].width) {
      return i
    }
  }
}

// 优化后：直接计算（O(1)）
getTrackByX(x) {
  const trackWidth = SCREEN_WIDTH / 4
  const index = Math.floor(x / trackWidth)
  return (index >= 0 && index < 4) ? index : -1
}
```

### 1.4 帧率优化

#### 自适应降级

**策略：**
```javascript
class PerformanceMonitor {
  fps = 60
  frameTimeHistory = []
  
  update(frameTime) {
    this.frameTimeHistory.push(frameTime)
    if (this.frameTimeHistory.length > 60) {
      this.frameTimeHistory.shift()
    }
    
    // 计算平均帧时间
    const avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b) / 
                         this.frameTimeHistory.length
    this.fps = 1000 / avgFrameTime
    
    // 帧率过低，降级
    if (this.fps < 45) {
      this.applyLowPerformanceMode()
    }
  }
  
  applyLowPerformanceMode() {
    // 减少粒子效果
    // 降低阴影质量
    // 简化动画
    console.log('进入低性能模式')
  }
}
```

**降级措施：**
- 禁用粒子效果
- 减少判定区域透明度层次
- 简化UI渲染
- 降低音符下落密度

## 2. 代码质量优化

### 2.1 错误处理优化

#### 防御性编程

**数据验证：**
```javascript
class DataBus {
  addScore(hitType) {
    // 验证参数
    if (!['PERFECT', 'GOOD', 'MISS'].includes(hitType)) {
      console.warn('无效的命中类型:', hitType)
      return
    }
    
    // 验证状态
    if (this.isGameOver) {
      console.warn('游戏已结束，不能添加分数')
      return
    }
    
    // 执行逻辑...
  }
}
```

**API容错：**
```javascript
class Music {
  playHitSound(type) {
    try {
      if (typeof wx !== 'undefined' && 
          typeof wx.vibrateShort === 'function') {
        wx.vibrateShort({ type: 'light' })
      }
    } catch (error) {
      console.warn('震动反馈失败:', error)
      // 不影响游戏继续
    }
  }
}
```

**降级方案：**
```javascript
loadPatternData() {
  try {
    // 方案1：加载外部JSON
    await loadFromNetwork()
  } catch (error) {
    console.warn('网络加载失败:', error)
    
    try {
      // 方案2：加载本地缓存
      await loadFromCache()
    } catch (error2) {
      console.warn('缓存加载失败:', error2)
      
      // 方案3：使用内置默认数据
      this.loadDefaultPatterns()
    }
  }
}
```

### 2.2 日志系统

#### 分级日志

**实现：**
```javascript
class Logger {
  static level = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3
  }
  
  static currentLevel = Logger.level.INFO
  
  static debug(...args) {
    if (this.currentLevel <= this.level.DEBUG) {
      console.log('[DEBUG]', ...args)
    }
  }
  
  static info(...args) {
    if (this.currentLevel <= this.level.INFO) {
      console.log('[INFO]', ...args)
    }
  }
  
  static warn(...args) {
    if (this.currentLevel <= this.level.WARN) {
      console.warn('[WARN]', ...args)
    }
  }
  
  static error(...args) {
    if (this.currentLevel <= this.level.ERROR) {
      console.error('[ERROR]', ...args)
    }
  }
}
```

**使用：**
```javascript
// 开发环境
Logger.currentLevel = Logger.level.DEBUG

// 生产环境
Logger.currentLevel = Logger.level.WARN

// 代码中
Logger.debug('节拍生成:', note)
Logger.info('游戏开始, BPM:', bpm)
Logger.warn('数据加载失败，使用默认配置')
Logger.error('致命错误:', error)
```

### 2.3 性能监控

#### 性能指标收集

**实现：**
```javascript
class PerformanceTracker {
  metrics = {
    fps: [],
    noteCount: [],
    renderTime: [],
    updateTime: []
  }
  
  startFrame() {
    this.frameStartTime = performance.now()
  }
  
  markRenderStart() {
    this.renderStartTime = performance.now()
  }
  
  markRenderEnd() {
    const renderTime = performance.now() - this.renderStartTime
    this.metrics.renderTime.push(renderTime)
  }
  
  endFrame() {
    const frameTime = performance.now() - this.frameStartTime
    const fps = 1000 / frameTime
    
    this.metrics.fps.push(fps)
    this.metrics.noteCount.push(GameGlobal.databus.notes.length)
    
    // 每秒输出一次
    if (this.metrics.fps.length >= 60) {
      this.report()
      this.reset()
    }
  }
  
  report() {
    const avgFps = average(this.metrics.fps)
    const avgRenderTime = average(this.metrics.renderTime)
    
    console.log(`性能报告:
      平均FPS: ${avgFps.toFixed(1)}
      平均渲染时间: ${avgRenderTime.toFixed(2)}ms
      节拍数量: ${Math.max(...this.metrics.noteCount)}
    `)
  }
}
```

## 3. 功能扩展策略

### 3.1 音乐同步功能

#### 设计方案

**架构：**
```javascript
class MusicSyncEngine {
  audioContext = null
  audioBuffer = null
  bpm = 120
  offset = 0  // 音频偏移（毫秒）
  
  async loadMusic(url) {
    // 加载音频文件
    const response = await fetch(url)
    const arrayBuffer = await response.arrayBuffer()
    
    this.audioContext = new AudioContext()
    this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer)
  }
  
  play() {
    const source = this.audioContext.createBufferSource()
    source.buffer = this.audioBuffer
    source.connect(this.audioContext.destination)
    source.start(0)
    
    // 记录开始时间
    this.musicStartTime = this.audioContext.currentTime
  }
  
  getCurrentBeat() {
    const currentTime = this.audioContext.currentTime - this.musicStartTime
    const beatDuration = 60 / this.bpm
    return Math.floor(currentTime / beatDuration)
  }
  
  getBeatTime(beatIndex) {
    const beatDuration = 60 / this.bpm
    return this.musicStartTime + beatIndex * beatDuration + this.offset / 1000
  }
}
```

**节拍生成调整：**
```javascript
class BeatGenerator {
  musicSync = null
  
  generateSyncedBeats() {
    if (!this.musicSync) return
    
    const currentBeat = this.musicSync.getCurrentBeat()
    const beatPattern = this.getCurrentPattern()
    
    // 根据当前节拍生成对应的音符
    if (beatPattern[currentBeat]) {
      const track = beatPattern[currentBeat].track
      const beatTime = this.musicSync.getBeatTime(currentBeat)
      
      this.createNoteAtTime(track, beatTime)
    }
  }
}
```

**BPM检测：**
```javascript
class BPMDetector {
  async detectBPM(audioBuffer) {
    // 1. 提取音频数据
    const channelData = audioBuffer.getChannelData(0)
    
    // 2. 计算能量包络
    const envelope = this.calculateEnvelope(channelData)
    
    // 3. 检测峰值
    const peaks = this.detectPeaks(envelope)
    
    // 4. 计算间隔
    const intervals = this.calculateIntervals(peaks)
    
    // 5. 统计最可能的BPM
    const bpm = this.findMostLikelyBPM(intervals)
    
    return bpm
  }
}
```

### 3.2 谱面编辑器

#### 设计方案

**数据结构：**
```javascript
class Chart {
  metadata = {
    title: '',
    artist: '',
    bpm: 120,
    difficulty: 'medium'
  }
  
  notes = [
    {
      time: 1000,      // 毫秒
      track: 0,        // 轨道0-3
      type: 'normal',  // normal/strong/weak
      duration: 0      // 长按时间（0=单点）
    }
  ]
  
  export() {
    return JSON.stringify({
      metadata: this.metadata,
      notes: this.notes
    })
  }
  
  import(data) {
    const chart = JSON.parse(data)
    this.metadata = chart.metadata
    this.notes = chart.notes
  }
}
```

**编辑器界面：**
```javascript
class ChartEditor {
  // 时间轴视图
  renderTimeline(ctx) {
    // 绘制时间刻度
    // 绘制4条轨道
    // 绘制已有音符
  }
  
  // 添加音符
  addNote(time, track) {
    this.chart.notes.push({
      time,
      track,
      type: this.selectedNoteType
    })
    
    // 按时间排序
    this.chart.notes.sort((a, b) => a.time - b.time)
  }
  
  // 删除音符
  removeNote(noteIndex) {
    this.chart.notes.splice(noteIndex, 1)
  }
  
  // 播放预览
  preview() {
    this.loadChart(this.chart)
    this.startGame()
  }
}
```

### 3.3 排行榜系统

#### 设计方案

**数据模型：**
```javascript
class Leaderboard {
  async submitScore(score, chartId) {
    const entry = {
      userId: this.getCurrentUserId(),
      username: this.getCurrentUsername(),
      score: score.score,
      accuracy: score.accuracy,
      maxCombo: score.maxCombo,
      chartId: chartId,
      timestamp: Date.now()
    }
    
    // 提交到服务器
    await this.api.post('/leaderboard/submit', entry)
  }
  
  async getTopScores(chartId, limit = 10) {
    const response = await this.api.get('/leaderboard/top', {
      chartId,
      limit
    })
    
    return response.data
  }
  
  async getUserRank(userId, chartId) {
    const response = await this.api.get('/leaderboard/rank', {
      userId,
      chartId
    })
    
    return response.data.rank
  }
}
```

**UI显示：**
```javascript
class LeaderboardUI {
  render(ctx, scores) {
    ctx.fillStyle = '#2c3e50'
    ctx.fillRect(50, 50, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 100)
    
    ctx.fillStyle = '#ecf0f1'
    ctx.font = 'bold 24px Arial'
    ctx.fillText('排行榜', SCREEN_WIDTH / 2, 100)
    
    scores.forEach((entry, index) => {
      const y = 150 + index * 40
      
      // 排名
      ctx.fillText(`${index + 1}`, 80, y)
      
      // 用户名
      ctx.fillText(entry.username, 150, y)
      
      // 分数
      ctx.textAlign = 'right'
      ctx.fillText(entry.score, SCREEN_WIDTH - 80, y)
      
      ctx.textAlign = 'left'
    })
  }
}
```

### 3.4 成就系统

#### 设计方案

**成就定义：**
```javascript
class AchievementSystem {
  achievements = [
    {
      id: 'first_perfect',
      name: '首次完美',
      description: '获得第一个PERFECT',
      icon: 'perfect.png',
      condition: (stats) => stats.perfectHits >= 1
    },
    {
      id: 'combo_master',
      name: '连击大师',
      description: '达成100连击',
      icon: 'combo.png',
      condition: (stats) => stats.maxCombo >= 100
    },
    {
      id: 'accuracy_pro',
      name: '精准专家',
      description: '精度达到95%',
      icon: 'accuracy.png',
      condition: (stats) => parseFloat(stats.accuracy) >= 95
    },
    {
      id: 'speed_demon',
      name: '速度恶魔',
      description: '在BPM180下完成一首歌',
      icon: 'speed.png',
      condition: (stats) => stats.bpm >= 180
    }
  ]
  
  unlockedAchievements = []
  
  checkAchievements(stats) {
    this.achievements.forEach(achievement => {
      // 已解锁，跳过
      if (this.unlockedAchievements.includes(achievement.id)) {
        return
      }
      
      // 检查条件
      if (achievement.condition(stats)) {
        this.unlockAchievement(achievement)
      }
    })
  }
  
  unlockAchievement(achievement) {
    this.unlockedAchievements.push(achievement.id)
    
    // 显示解锁通知
    this.showUnlockNotification(achievement)
    
    // 保存到本地存储
    this.saveToStorage()
  }
}
```

### 3.5 主题皮肤系统

#### 设计方案

**主题定义：**
```javascript
class Theme {
  static themes = {
    default: {
      name: '默认',
      colors: {
        track0: '#FF6B6B',
        track1: '#4ECDC4',
        track2: '#45B7D1',
        track3: '#96CEB4',
        background: '#000000',
        judgeLine: '#FFFFFF',
        perfectZone: '#FFD700',
        goodZone: '#00FF00'
      },
      fonts: {
        ui: 'Arial',
        score: 'Arial'
      }
    },
    
    neon: {
      name: '霓虹',
      colors: {
        track0: '#FF00FF',
        track1: '#00FFFF',
        track2: '#FFFF00',
        track3: '#00FF00',
        background: '#0a0a0a',
        judgeLine: '#FFFFFF',
        perfectZone: '#FF00FF',
        goodZone: '#00FFFF'
      }
    },
    
    retro: {
      name: '复古',
      colors: {
        track0: '#8B4513',
        track1: '#DAA520',
        track2: '#CD853F',
        track3: '#DEB887',
        background: '#2F4F4F',
        judgeLine: '#F5DEB3',
        perfectZone: '#FFD700',
        goodZone: '#98FB98'
      }
    }
  }
  
  static current = 'default'
  
  static getColor(key) {
    return this.themes[this.current].colors[key]
  }
  
  static switchTheme(themeName) {
    if (this.themes[themeName]) {
      this.current = themeName
      // 触发重新渲染
      GameGlobal.main.forceRender()
    }
  }
}
```

**应用主题：**
```javascript
class Note {
  getTrackColor(track) {
    // 使用主题颜色
    return Theme.getColor(`track${track}`)
  }
}

class TrackSystem {
  render(ctx) {
    // 判定线使用主题颜色
    ctx.strokeStyle = Theme.getColor('judgeLine')
    
    // PERFECT区域使用主题颜色
    ctx.fillStyle = Theme.getColor('perfectZone') + '30'
  }
}
```

## 4. 调试与测试策略

### 4.1 调试工具

#### 可视化调试

**实现：**
```javascript
class DebugOverlay {
  enabled = false
  
  render(ctx) {
    if (!this.enabled) return
    
    // 绘制FPS
    ctx.fillStyle = '#00FF00'
    ctx.font = '14px monospace'
    ctx.fillText(`FPS: ${GameGlobal.fps}`, 10, 200)
    
    // 绘制节拍数量
    ctx.fillText(`Notes: ${GameGlobal.databus.notes.length}`, 10, 220)
    
    // 绘制对象池状态
    const poolStats = GameGlobal.databus.pool.getPoolStats()
    ctx.fillText(`Pool: ${JSON.stringify(poolStats)}`, 10, 240)
    
    // 绘制判定区域边界
    const judgeZone = this.trackSystem.getJudgeZone()
    ctx.strokeStyle = '#FF0000'
    ctx.strokeRect(0, judgeZone.y, SCREEN_WIDTH, judgeZone.height)
    
    // 绘制节拍中心点
    GameGlobal.databus.notes.forEach(note => {
      const centerY = note.y + note.height / 2
      ctx.fillStyle = '#FF00FF'
      ctx.fillRect(note.x - 2, centerY - 2, 4, 4)
    })
  }
  
  toggle() {
    this.enabled = !this.enabled
  }
}
```

### 4.2 自动化测试

#### 单元测试示例

**测试框架：**
```javascript
// 使用Jest或类似框架

describe('DataBus', () => {
  let databus
  
  beforeEach(() => {
    databus = new DataBus()
    databus.reset()
  })
  
  test('应该正确计算分数', () => {
    databus.addScore('PERFECT')
    expect(databus.score).toBe(300)
    
    databus.addScore('PERFECT')
    expect(databus.score).toBe(630)  // 300 * 1.1
  })
  
  test('应该正确管理连击', () => {
    databus.addScore('PERFECT')
    databus.addScore('PERFECT')
    expect(databus.combo).toBe(2)
    
    databus.addScore('MISS')
    expect(databus.combo).toBe(0)
  })
  
  test('应该限制连击倍率上限', () => {
    for (let i = 0; i < 30; i++) {
      databus.addScore('PERFECT')
    }
    
    const multiplier = databus.calculateScore(100, databus.combo) / 100
    expect(multiplier).toBeLessThanOrEqual(3)
  })
})
```

### 4.3 性能测试

#### 压力测试

**实现：**
```javascript
class StressTest {
  async runTest() {
    console.log('开始压力测试...')
    
    // 测试1：大量节拍
    await this.testManyNotes(200)
    
    // 测试2：高BPM
    await this.testHighBPM(200)
    
    // 测试3：长时间运行
    await this.testLongRunning(60000)  // 1分钟
    
    console.log('压力测试完成')
  }
  
  async testManyNotes(count) {
    console.log(`测试 ${count} 个节拍...`)
    
    for (let i = 0; i < count; i++) {
      const note = new Note()
      note.init(i % 4, Date.now())
      GameGlobal.databus.notes.push(note)
    }
    
    // 运行10秒
    await this.runFor(10000)
    
    console.log('节拍测试完成，平均FPS:', this.avgFps)
  }
}
```

---

**总结：**

本文档涵盖了节奏游戏的各项优化和扩展策略：

**优化方面：**
- 渲染性能：分层、批量、缓存
- 内存管理：对象池、资源释放、定时清理
- 计算优化：缓存、查找表、算法改进
- 代码质量：错误处理、日志、监控

**扩展方面：**
- 音乐同步：BPM检测、精确同步
- 谱面编辑：可视化编辑、导入导出
- 社交功能：排行榜、成就系统
- 视觉增强：主题皮肤、粒子效果

**调试测试：**
- 可视化调试工具
- 自动化单元测试
- 性能压力测试

这些策略为项目的持续优化和功能扩展提供了清晰的方向和具体的实现方案。

**文档版本**：v1.0  
**创建日期**：2025-10-12  
**最后更新**：2025-10-12
